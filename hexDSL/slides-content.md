# hexDSL

**DSL** toolkit written in Haxe. 

---

## Workshop's goal
Discover basics of `hexDSL`   
Only focus on **Flow** and **Static Compiler**
<!-- only the basics -->

---

![diagram](resource/schema-dsl.png)  <!-- .element: style="border: 0; background: None; box-shadow: None; max-height:640px" -->

<!-- hexIoC is an extends version of hexDSL -->

---

## Domain-Specific language ? 

 > Computer language specialized to a particular application domain

Can also be descried as a simple language dedicated to a particular purpose.  
Think about `RegExp`, `HTML`, `SQL`, `Ant`

---

## For what ?
**DSL** in `hexMachina` is used as a configuration language.  
**Flow** language is only for configuration!
<!-- `hexMachina` framework is based on IoC pattern. -->

---

## Flow?

**Flow** is a very limited Haxe flavour language.  
no `conditional`, no `loops`, no `function`, no `logic`

---

## Declarative language

Describe your need in any order,  
the `Assembler` will calculated order execution for you! 

---

## Source code splitted

### Flow
describe **WHAT** should be used 

### Haxe  
describe **HOW** it should works

---

#### Not a Universal solution

`hexDSL` force abstraction, and low coupling  
### Usefull for   
* Huge project
* long live support

*But have a energy cost at the begining*

<!-- Symplify migration -->

---

# StaticCompiler ? 

--

### Flow
```haxe
@context( name = 'applicationContextName' )
{
  s = "Hello world !";
}
```

### Generated by Macro
```haxe
class hex.context.applicationContextName 
  implements hex.context.IapplicationContextName 
{
	public var s:String;

	public function m_059f92dea409490fbace9ef2fa1516a7() 
	{
		var s = "Hello world !";
		this.s = s;
	}
}
```
Each `context` is converted in a Class.  
By Macro, **Flow** DSL is converted in Haxe code, and then compiled to target language.  

<!-- This solution provide all the power of Haxe compiler, type checking, auto-completion in IDE... -->

--

Every context properties are available externally through a locator. 

```haxe
interface hex.context.IapplicationContextName 
{
	var s:String;

	@:noCompletion
	function m_059f92dea409490fbace9ef2fa1516a7():Void;
}
```

```haxe
// convert context in class by Macro
var code = BasicStaticFlowCompiler.compile( new ApplicationAssembler(), "helloworld.flow" );
// null
trace( code.locator.s ); 
// execute context at runtime
code.execute();
// "Hello world !"
trace( code.locator.s ); 
```
*`code.locator` is typed `hex.context.IapplicationContextName`*

--

`hexDSL` support also **XML** 

```haxe
@context( name = 'applicationContextName' )
{
  s = "Hello world !";
}
```
### XML
```xml
<root name="applicationContextName">
    <test id="s" value="Hello world !">
</root>
```

---

# Simple Instantiation

--

### Primitives
```Haxe
@context()
{
  s = 'hello';
  i = -3;
  h = 0xFFFFFF;
  @type( 'UInt' )
  u = 3;
  b = true;
  n = null;
}
```
```haxe
public var s:String;
public var i:Int;
public var h:Int;
public var u:UInt;
public var b:Bool;
public var n:Dynamic;

public function m_f276878bc4550514b52bbd06bac65d48() 
{
    var s = "hello";
    this.s = s;
    var i = -3;
    this.i = i;
    var h = 16777215;
    this.h = h;
    var u = 3;
    this.u = u;
    var b = true;
    this.b = b;
    var n = null;
    this.n = n;
}
```
*`@type` allow you to force type. *
<!-- type inferance / force type with @type -->

--

## Simple class instance 

```haxe
instance = new hex.mock.MockClassWithoutArgument();
```
Generated Haxe
```haxe 
var instance = new hex.mock.MockClassWithoutArgument();
```

--

## Instance with arguments 

```haxe
d = new Date(2013, 12, 2, 12, 9, 0);
```
Generated Haxe
```haxe
var d = new Date(2013, 12, 2, 12, 9, 0);
```

--

## Anonymous object 

```haxe
obj = { 
  name: "Francis", 
  age: 44, 
  height: 1.75, 
  isWorking: true 
  isSleeping: false;
};
```
Generated Haxe
```haxe
var obj = {};
obj.name = "Francis";
obj.age = 44;
obj.height = 1.75;
obj.isWorking = true;
obj.isSleeping = false;
```

--

## property

```haxe
obj = {};
obj.name = "Francis";
obj.age = 44;
obj.height = 1.75;
obj.isWorking = true;
obj.isSleeping = false;
```
Generated Haxe
```haxe
var obj = {};
obj.name = "Francis";
obj.age = 44;
obj.height = 1.75;
obj.isWorking = true;
obj.isSleeping = false;
```

---

# Exercise 1
### Cheat sheet
```haxe
s = 'hello';
```
```haxe
instance = new hex.mock.MockClassWithoutArgument();
```
```haxe
d = new Date(2013, 12, 2, 12, 9, 0);
```
```haxe
obj = { property: "value" };
```
```haxe
obj.name = "Francis";
```

---

# References

--

### Use reference as argument
```haxe
colors = new Array<Int>(black, white, red, green, blue);
// or colors = [black, white, red, green, blue];

black = 0x000000;
white = 0xFFFFFF;
red = 0xFF0000;
green = 0x00FF00;
blue = 0x0000FF;
```
Generated Haxe
```haxe
var black = 0;
var white = 16777215;
var red = 16711680;
var green = 65280;
var blue = 255;

var colors = [black, white, red, green, blue];
```

--

### Use property as reference
```haxe
rect = new js.html.DOMRect(position.x, position.y, size.x, size.y);
position = new js.html.DOMPoint(30, 40);
size = new js.html.DOMPoint(10, 20);
```
Generated Haxe
```haxe
var position = new DOMPoint(30, 40);
var size = new DOMPoint(10, 20);
var rect = new DOMRect(position.x, position.y, size.x, size.y);
```

--

### Class reference

```haxe
classContainer = { classReference: requestClass };
requestClass = haxe.web.Request;
```
Generated Haxe
```haxe
public var classContainer:Dynamic;
public var requestClass:Class<haxe.web.Request>;

... 

var classContainer = {};
var requestClass = haxe.web.Request;
classContainer.classReference = requestClass;
```

--

### Static reference
```haxe
logLevels = new Array<hex.log.LogLevel>(
  hex.log.LogLevel.ALL, 
  hex.log.LogLevel.DEBUG, 
  hex.log.LogLevel.INFO, 
  hex.log.LogLevel.WARN, 
  hex.log.LogLevel.ERROR, 
  hex.log.LogLevel.FATAL
);
```
Generated Haxe
```haxe
// hex.log.LogLevel is abstract class
var basicTypes = [ 
  hex.log._LogLevel.LogLevel_Impl_._ALL, 
  hex.log._LogLevel.LogLevel_Impl_._DEBUG, 
  hex.log._LogLevel.LogLevel_Impl_._INFO, 
  hex.log._LogLevel.LogLevel_Impl_._WARN, 
  hex.log._LogLevel.LogLevel_Impl_._ERROR, 
  hex.log._LogLevel.LogLevel_Impl_._FATAL
];
```

--

### alias

Sometime, it could be usefull to alias a reference. 
```haxe
@type('Int')
intDebug = debug;
debug = hex.log.LogLevel.DEBUG;
```

```haxe
public var debug:hex.log.LogLevel;
public var intDebug:Int;

...

var debug = hex.log._LogLevel.LogLevel_Impl_._DEBUG;
this.debug = debug;
var intDebug = debug;
this.intDebug = @:implicitCast hex.log._LogLevel.LogLevel_Impl_.toInt(intDebug);
```

---

# Exercise 2
### Cheat sheet
```haxe
instance_ref = new Array<Int>(black, white, red, green, blue);
```
```haxe
property_ref = position.x;
```
```haxe
static_ref = hex.log.LogLevel.ALL;
```
```haxe
class_ref = haxe.web.Request;
```

---

# Method call

--

### code.execute()

![diagram](resource/dsl-context-execute.png)  <!-- .element: style="border: 0; background: None; box-shadow: None; max-height:640px" -->

--

### method call
```haxe
issuesRequest.addParameter("project", "doclerlabs/hexMachina");
issuesRequest = new haxe.Http("https://api.github.com/search/issues");
```
Generated Haxe
```haxe
applicationContext.dispatch(hex.core.ApplicationAssemblerMessage.ASSEMBLING_START, null);

var issuesRequest = new haxe.Http("https://api.github.com/search/issues");
this.issuesRequest = issuesRequest;

applicationContext.dispatch(hex.core.ApplicationAssemblerMessage.OBJECTS_BUILT, null);

issuesRequest.addParameter("project", "doclerlabs/hexMachina");

applicationContext.dispatch(hex.core.ApplicationAssemblerMessage.METHODS_CALLED, null);
applicationContext.dispatch(hex.core.ApplicationAssemblerMessage.MODULES_INITIALIZED, null);
applicationContext.dispatch(hex.core.ApplicationAssemblerMessage.ASSEMBLING_END, null);
```

--

### static call
```xml
random = Math.random();
```
Generated Haxe
```haxe
var random = Math.random();
```

--

### factory method
```haxe
logger = hex.log.LoggerContext.getContext().getLogger("myLogger");
```
Generated Haxe
```haxe
var logger = hex.log.LoggerContext.getContext().getLogger("myLogger", null);
```

---

# Exercise 3
### Cheat sheet
```haxe
issuesRequest.addParameter("project", "doclerlabs/hexMachina");
```
```xml
random = Math.random();
```
```haxe
logger = hex.log.LoggerContext.getContext().getLogger("myLogger");
```

---

# Context Injector
Each context has is own injector

--

## Mapping with `@map_type`

`@map_type` map by ClassName and name, `ToValue` in context injector.  
```haxe
@map_type( 'hex.mock.IMockInterface' ) 
instance = new hex.mock.MockClass();
```
Generated Haxe
```haxe
var instance = new hex.mock.MockClass();
__applicationContextInjector.mapClassNameToValue("hex.mock.IMockInterface", instance, "instance");
```
equal to
```haxe
contextInjector.mapClassName( "hex.mock.IMockInterface", "instance" ).toValue( instance );
```

--

## Apply injection with `@inject_into`

`@inject_into` = `ContextInjector.injectInto(instance)`
```haxe
@inject_into 
instance = new hex.mock.MockClassWithInjectedProperty();
@map_type( 'String' ) 
injected = "hola mundo";
```
Generated Haxe
```haxe
var instance = new hex.mock.MockClassWithInjectedProperty();
this.instance = instance;
var injected = "hola mundo";
this.injected = injected;
__applicationContextInjector.mapClassNameToValue("String", injected, "injected");
__applicationContextInjector.injectInto(instance);
```

---

# Exercise 4
### Cheat sheet
```haxe
@map_type( 'String' ) 
injected = "hola mundo";
```
```haxe
@inject_into 
instance = new hex.mock.MockClassWithInjectedProperty();
```

---

# MappingDefinition

--

## hex.di.mapping.MappingDefinition
An easy way to discribe a mapping 
```haxe
typedef MappingDefinition =
{
	var fromType                : String;
	@:optional var withName     : String;
	
	@:optional var toClass      : Class<Dynamic>;
	@:optional var toValue      : Any;
	
	@:optional var asSingleton  : Bool;
	@:optional var injectInto   : Bool;
}
```

--

## mapping
Use `mapping` to check values of `MappingDefinition`
```haxe
mapping = mapping({fromType: "String", toValue: "test"});
```
Generated Haxe
```haxe
var mapping = {
  injectInto : false, 
  withName : "", 
  toClass : null, 
  asSingleton : false, 
  fromType : "String", 
  toValue : @:implicitCast cast "test"
};
```

--

`Array<hex.di.mapping.MappingDefinition>`
```haxe
mapping = mapping({fromType: "String", toValue: "test"});
mappings = new Array<hex.di.mapping.MappingDefinition>
(
  mapping, 
  mapping( {fromType: "hex.mock.Interface", toClass: hex.mock.Clazz, withName: "id"} )
);
```
Generated Haxe
```haxe
var mapping = { 
  injectInto : false, 
  withName : "", 
  toClass : null, 
  asSingleton : false, 
  fromType : "String", 
  toValue : @:implicitCast cast "test"
};
this.mapping = mapping;
var mappings = [
  mapping, 
  {injectInto : false, 
  asSingleton : false, 
  toValue : null, 
  fromType : "hex.mock.Interface", 
  toClass : cast hex.mock.Clazz, 
  withName : "id"}
];
this.mappings = mappings;
```

--

## IDependencyOwner

`@Dependency` - define your injection need and it will be checked at compilation
```haxe
@Dependency( var test:String )
@Dependency( var id:hex.mock.Interface )
class DependencyOwnerTest implements IDependencyOwner
{
    var _injector : Injector = new Injector();

    public function new( mapping : Array<hex.di.mapping.MappingDefinition> ) 
    {
        // mapping is done by Macro in constructor through hex.di.mapping.IDependencyOwner
        // all @Dependency are checked at compilation
    }

    public function getInjector() : IDependencyInjector
    {
        return _injector;
    }
}
```

---

# Exercise 5
### Cheat sheet
```haxe
typedef MappingDefinition =
{
	var fromType                : String;
	@:optional var withName     : String;
	
	@:optional var toClass      : Class<Dynamic>;
	@:optional var toValue      : Any;
	
	@:optional var asSingleton  : Bool;
	@:optional var injectInto   : Bool;
}
```
```haxe
mapping1 = mapping({fromType: "String", toValue: "test"});
```

---

# More features

--

## runtime parameters

```haxe
@context( params = {x: Float, y: Float, p:hex.structures.Point} )
{
	size = new hex.structures.Size( x, y );
	anotherSize = new hex.structures.Size( p.x, p.y );
}
```
Usage
```haxe
var code = BasicStaticFlowCompiler.compile( this._myApplicationAssembler, "context/flow/runtimeArguments.flow", "BasicStaticFlowCompiler_testRuntimeArguments" );
code.execute( { x:10, y: 20, p: new Point( 30, 40 ) } );
```

--

## include and if/else
include == merge files
```haxe
@context( name = 'applicationContext' )
#if ( prodz == 'true' )
@include( 'context/flow/ifAttribute.flow' )
#end
{
	test = 'hello world';
}
```

--

## import
Create a parent-children context relation
```haxe
@context( name = 'applicationContext' )
{
	childContext = new Context( 'context/flow/static/beImportedMessage.flow', {message: message, to: name} );
	message = "hello";
	name = "world";
}
```

--

## @lazy
```haxe
@lazy
s = hex.mock.LazyProvider.provide( 'test' );
```
Generated Haxe
```haxe
@:noCompletion
public function get_s() {
  if ((this.s == null)) this.s = hex.mock.LazyProvider.provide("test");
  return this.s;
}
```

--

## @parser
Create your own API
```haxe
@context( name = 'applicationContext' )
@parser( hex.compiletime.flow.parser.custom.AddParser )
{
	s = add( "hello", space, "world", space, "!" );
	space =  " ";
	
	i = add( 6, five );
	five = 5;

	p = add( p1, new hex.structures.Point( 3, 4 ), p2 );
	p1 = new hex.structures.Point( 5, 5 );
	p2 = new hex.structures.Point( 3, 4 );
}
```
Generated Haxe
```haxe
var space = " ";
var s = "hello" + space + "world" + space + "!";

var five = 5;
var i = 6 + five;

var this1 = {x : 5, y : 5};
var p1 = cast this1;
var this2 = {x : 3, y : 4};
var p2 = cast this2;
var this3 = {x : 3, y : 4};
var p21 = cast this3;
var p11 = cast {x : cast p1.x + cast p21.x, y : cast p1.y + cast p21.y};
var p = cast {x : cast p11.x + cast p2.x, y : cast p11.y + cast p2.y};
```

---

## More
* [documentation](https://github.com/DoclerLabs/hexDSL/blob/master/src/hex/compiletime/flow/README.md)
* [context tests](https://github.com/DoclerLabs/hexDSL/tree/master/test/context)
